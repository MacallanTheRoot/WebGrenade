/**
 * WebGrenade v3.2.0 — inject.js
 *
 * Runs in the MAIN WORLD (loaded via <script src="chrome-extension://..."> from content.js).
 * This approach is CSP-safe because the browser validates the src URL against the extension
 * origin, not the page's Content-Security-Policy.
 *
 * Advanced schomery-style popup blocker:
 *   1. Proxy window.open → null
 *   2. Capture-phase click/auxclick/submit listener — blocks UNTRUSTED events that target _blank
 *   3. document.createElement proxy — catches programmatic anchor/form .click()/.submit() calls
 *
 * STRICT: No innerHTML anywhere.
 */

(function () {
    'use strict';

    // ── Guard: Only install once ───────────────────────────────────────────────
    if (window.__wgInjected) return;
    window.__wgInjected = true;

    // ── 1. Proxy window.open ───────────────────────────────────────────────────
    // Store original so callers that explicitly saved a reference still work,
    // but calls going through window.open are intercepted.
    const _originalOpen = window.open;
    window.__wgOriginalOpen = _originalOpen;

    window.open = new Proxy(_originalOpen, {
        apply(target, thisArg, args) {
            const url = args[0] || '';
            console.log('[WebGrenade] window.open() intercepted and blocked:', url || '(no url)');
            window.postMessage({
                source: 'webgrenade',
                action: 'popup_blocked',
                url: String(url)
            }, '*');
            return null;
        }
    });

    // ── 2. Capture-phase event listener (click / auxclick / submit) ────────────
    // Blocks events that:
    //   a) Are NOT trusted (isTrusted === false) — meaning generated by scripts, not real input
    //   b) Would open a new tab (target="_blank" anchor, or form target="_blank")
    //
    // This catches the pattern: elem.dispatchEvent(new MouseEvent('click')) on a _blank link.
    //
    // We use capture phase so we run BEFORE the page's own listeners.

    function isBlankTarget(el) {
        if (!el) return false;
        const tag = el.tagName;
        if (tag === 'A' || tag === 'AREA') {
            return (el.target || '').toLowerCase() === '_blank';
        }
        if (tag === 'FORM') {
            return (el.target || '').toLowerCase() === '_blank';
        }
        // Walk up to find a parent anchor
        const anchor = el.closest('a[target="_blank"], area[target="_blank"]');
        return !!anchor;
    }

    function blockingListener(event) {
        // Only block script-generated (untrusted) events targeting new tabs
        if (event.isTrusted) return;
        if (!isBlankTarget(event.target)) return;

        // Extract the blocked URL before stopping the event
        const anchor = event.target.closest('a[href], area[href]') || event.target;
        const blockedUrl = anchor.href || anchor.action || '';

        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();

        console.log('[WebGrenade] Untrusted', event.type, 'to _blank blocked:', blockedUrl);
        window.postMessage({
            source: 'webgrenade',
            action: 'popup_blocked',
            url: blockedUrl
        }, '*');
    }

    document.addEventListener('click', blockingListener, { capture: true, passive: false });
    document.addEventListener('auxclick', blockingListener, { capture: true, passive: false });
    document.addEventListener('submit', blockingListener, { capture: true, passive: false });

    // ── 3. Proxy document.createElement to catch self-clicking anchors ─────────
    // Pattern: scripts do:
    //   const a = document.createElement('a');
    //   a.href = '...'; a.target = '_blank'; a.click(); ← never attached to DOM
    //
    // We intercept by wrapping HTMLAnchorElement.prototype.click and
    // HTMLFormElement.prototype.submit with guards activated only when the element
    // is NOT in the document (ghost elements created purely for popup navigation).

    const _anchorClick = HTMLAnchorElement.prototype.click;
    const _formSubmit = HTMLFormElement.prototype.submit;

    HTMLAnchorElement.prototype.click = function wgAnchorClick() {
        if (
            !document.contains(this) &&                             // detached from DOM
            (this.target || '').toLowerCase() === '_blank'          // aiming for new tab
        ) {
            console.log('[WebGrenade] Ghost anchor .click() blocked:', this.href);
            return;
        }
        return _anchorClick.apply(this, arguments);
    };

    HTMLFormElement.prototype.submit = function wgFormSubmit() {
        if (
            !document.contains(this) &&
            (this.target || '').toLowerCase() === '_blank'
        ) {
            console.log('[WebGrenade] Ghost form .submit() blocked.');
            return;
        }
        return _formSubmit.apply(this, arguments);
    };

    // ── Disable: restore everything ────────────────────────────────────────────
    // Content script can signal disable by setting window.__wgDisablePopupBlocker = true
    // and dispatching a custom event.
    window.addEventListener('__wgDisablePopupBlocker', () => {
        window.open = window.__wgOriginalOpen || _originalOpen;
        HTMLAnchorElement.prototype.click = _anchorClick;
        HTMLFormElement.prototype.submit = _formSubmit;
        document.removeEventListener('click', blockingListener, { capture: true });
        document.removeEventListener('auxclick', blockingListener, { capture: true });
        document.removeEventListener('submit', blockingListener, { capture: true });
        window.__wgInjected = false;
        window.__wgOriginalOpen = undefined;
        console.log('[WebGrenade] Popup blocker disabled.');
    });

    console.log('[WebGrenade] inject.js active — advanced popup blocker running.');
})();
